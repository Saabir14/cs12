// Created By Saabir A Parvaiz. Unauthorised claims of this project source-code, unauthorised editing or unauthorised copying will result in legal action.

// Includes
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <strings.h>
#include <unistd.h>
#include "resources/colors.h"
typedef char *string;



// Prototypes
bool strIncludesChar(string s, char c);
bool strIsAlpha(string s);
void strExpf(string fname, char out[]);
int findDM(char dm, string fname);
bool gridf(string fname);
int memError();
long findCharsf(string fname);
int strPos(char str1[], char str2[]);
int findDigits(int number);
void tostring(char str[], int num);
void strlower(string s);
void strupper(string s);



int main(int argc, string argv[])
{
    // Credit to Saabir
    string credits = "\tResults Generated By Saabir's Word Searcher\n";

    // Error check
    if (argc < 3)
    {
        colorSet("y");
        printf("\t\tUsage: ./wordSearch [Puzzle File] [Word1] [Word2] [Word3]...\n\n");
        colorSet("c");
        printf("%s", credits);
        colorSet("reset");
        return 1;
    }

    string puzzle = argv[1];
    FILE* test = fopen(puzzle, "r");
    {
        if (test == NULL)   // Checking If Puzzle File Exist
        {
            colorSet("rb");
            printf("\t\tFile Or Directory Named '%s' Does Not Exist!", puzzle);
            colorSet("r");
            printf("\tTerminating...\n\n");
            colorSet("c");
            printf("%s", credits);
            colorSet("reset");
            return 2;
        }
        fclose(test);
    }

    // Setting Basic Values
    string out = "-Out.html";
    int argumentN = argc - 2;
    string arguments[argumentN];
    for (int i = 0; i < argumentN; i++)
    {
        arguments[i] = argv[i + 2];
    }
    bool append = false;
    bool ignore = false;

    // Placing arguments in array
    int fileN = 0, wordN = 0;
    for (int i = 0; i < argumentN; i++)
    {
        if (arguments[i])
        {
            if (strcasecmp(arguments[i], "-IGNOREFAIL") == 0)
            {
                if (ignore)
                {
                    colorSet("yb");
                    printf("\t\t'%s' Is A Repeated Argument!", arguments[i]);
                    colorSet("r");
                    printf("\tIgnoring...\n");
                    colorSet("reset");
                    arguments[i] = NULL;
                }
                ignore = true;
            }
            else if (strcasecmp(arguments[i], "-app") == 0)
            {
                if (append)
                {
                    colorSet("yb");
                    printf("\t\t'%s' Is A Repeated Argument!", arguments[i]);
                    colorSet("r");
                    printf("\tIgnoring...\n");
                    colorSet("reset");
                    arguments[i] = NULL;
                }
                append = true;
            }
            else if (arguments[i][0] == '-' && strIncludesChar(arguments[i], '.'))
            {
                if (strcmp(out, "-Out.html") != 0)
                {
                    colorSet("yb");
                    printf("\t\t'%s' Is A Repeated Argument!", arguments[i]);
                    colorSet("r");
                    printf("\tIgnoring...\n");
                    colorSet("reset");
                    arguments[i] = NULL;
                }
                else
                {
                    out = arguments[i];
                }
            }
            else if (strIncludesChar(arguments[i], '.'))
            {
                fileN++;
            }
            else if (strIsAlpha(arguments[i]))
            {
                wordN++;
            }
            else
            {
                colorSet("yb");
                printf("\t\t'%s' Is An Invalid Word!", arguments[i]);
                colorSet("r");
                printf("\tIgnoring...\n");
                colorSet("reset");
            }
        }
    }


    string files[fileN];
    for (int i = 0; i < fileN; i++) {files[i] = NULL;}
    string words[wordN];
    for (int i = 0; i < wordN; i++) {words[i] = NULL;}

    int temps = 0, tempf = 0;
    for (int i = 0; i < argumentN; i++)
    {
        if (arguments[i] == NULL || strIncludesChar(arguments[i], '-'))
        {
            continue;
        }
        else if (strIncludesChar(arguments[i], '.'))
        {
            // Check for duplicate
            bool add = true;
            for (int j = 0; j < tempf; j++)
            {
                if (strcmp(arguments[i], arguments[j]) == 0)
                {
                    colorSet("yb");
                    printf("\t\t'%s' Is A Repeated File!", arguments[i]);
                    colorSet("r");
                    printf("\tIgnoring...\n");
                    colorSet("reset");
                    add = false;
                    break;
                }
            }

            if (add)
            {
                words[tempf] = arguments[i];
                tempf++;
            }
        }
        else if (strIsAlpha(arguments[i]))
        {
            // Check for duplicate
            bool add = true;
            for (int j = 0; j < temps; j++)
            {
                if (strcmp(arguments[i], arguments[j]) == 0)
                {
                    colorSet("yb");
                    printf("\t\t'%s' Is A Repeated Word!", arguments[i]);
                    colorSet("r");
                    printf("\tIgnoring...\n");
                    colorSet("reset");
                    add = false;
                    break;
                }
            }

            if (add)
            {
                words[temps] = arguments[i];
                temps++;
            }
        }
    }

    for (int i = 0; i < fileN; i++)
    {
        if (files[i])
        {
            FILE* file = fopen(files[i], "r");
            if (file == NULL)   // Checking if the file of words exists
            {
                colorSet("yb");
                printf("\t\tFile Or Directory Named '%s' Does Not Exist!", files[i]);
                colorSet("r");
                printf("\tIgnoring...\n");
                colorSet("reset");
                files[i] = NULL;
                continue;
            }
            else {fclose(file);}
        }
    }

    // Change Files To Strings And Run Creating a Recursion
    for (int i = 0; i < fileN; i++)
    {
        if (files[i] != NULL)   // Only running on existing files
        {
            long syze = findCharsf(files[i]);
            if (syze < 0) {return memError();}

            char f[syze + 1];
            for (int j = 0; j < syze +  1; j++) {f[j] = 0;}
            strExpf(files[i], f);

            if (strcmp(f, "-_-MEMERROR-_-") == 0 || f[0] == 0 || strcmp(f, "-_-NOFILE-_-") == 0) {return memError();}
            else if (strcmp(f, "-_-FEMPTY-_-") == 0)
            {
                colorSet("yb");
                printf("\t\tFile Or Directory Named '%s' Is Empty!", files[i]);
                colorSet("r");
                printf("\tIgnoring...\n");
                colorSet("reset");
            }
            else
            {
                string program = argv[0];
                int exelen = strlen(program) + strlen(puzzle) + strlen(f) + strlen("-app") + strlen(out) + strlen("-ignorefail") + 6;
                char exe[exelen];
                for (int c = 0; c < exelen; c++) {exe[c] = 0;}

                for (int j = 0; j < exelen; j++)
                {
                    if (exe[j] == 10) {exe[j] = ' ';}
                }
                for (int j = 0; j < exelen; j++) {exe[i] = 0;}

                for (int s = 0; s < syze; s++)
                {
                    if (!isalpha(f[s])) {f[s] = ' ';}
                }

                if (i == 0 && !append) {sprintf(exe, "%s %s %s %s", program, puzzle, f, out);}
                else {sprintf(exe, "%s %s %s %s %s", program, puzzle, f, "-app", out);}

                if(ignore)
                {
                    sprintf(exe, "%s %s", exe, "-ignorefail");
                }

                colorSet("bb");
                printf("\t\tNow Reading file '%s'\n", files[i]);
                colorSet("reset");
                system(exe);
            }
        }
    }

    if (temps < 1)
    {
        colorSet("c");printf("%s", credits);colorSet("reset");
        return 0;
    }

    // Read the puzzle into an array
    FILE* pfile = fopen(puzzle, "r");
    if (pfile == NULL) {return memError();}

    if (!gridf(puzzle)) // Checking if file is in a grid like shape
    {
        colorSet("yb");printf("\t\tFile or directory named '%s' is invalid!\n", puzzle);colorSet("y");printf("\t\tFile is not a rectangle or square.\n\t\tSee 'README.md' for help.\n");colorSet("rb");
        printf("\t\t\tTerminating...\n\n");colorSet("c");printf("%s", credits);colorSet("reset");fclose(pfile);return 1;
    }
    int x = findDM('x', puzzle), y = findDM('y', puzzle);
    if (x == 0)
    {
        colorSet("yb");printf("\t\tFile Or Directory Named '%s' Is Empty!\n", puzzle);colorSet("y");
        printf("\t\tNo letters found, The file must contain letters but can be seperated by other values.\n\t\tSee 'README.md' for help.\n");colorSet("rb");printf("\t\t\tTerminating...\n\n");colorSet("c");
        printf("%s", credits);colorSet("reset");fclose(pfile);return 1;
    }
    else if (x < 1 || y < 1) {return memError();}
    char p[x][y];

    for (int j = 0; j < y; j++)
    {
        for (int i = 0; i < x; i++)
        {
            p[i][j] = 0;
            do
            {
                p[i][j] = tolower(fgetc(pfile));
            }
            while (!isalpha(p[i][j]));
        }
    }
    fclose(pfile);

    // HTML
    string fcredits = "<h3 style=\"text-align: right;\"><i>Results generated by Saabir's word searcher</i></h3>";
    char outfile[strlen(out)];  // Generating Name
    for (int i = 0; i < strlen(out); i++) {outfile[i] = out[i + 1];}
    outfile[strlen(out) - 1] = 0;

    // Checking If Append Is Possible
    if(append)
    {
        FILE* html = fopen(outfile, "r");
        if (html)
        {
            int syze = findCharsf(outfile);
            if (syze < 0) {fclose(html);return memError();}
            else if (syze < strlen(fcredits)) {syze = strlen(fcredits);}

            char ftext[syze + 1];
            memset(ftext, 0, syze + 1);
            strExpf(outfile, ftext);
            fclose(html);

            if (strcmp(ftext, "-_-MEMERROR-_-") == 0 || ftext[0] == 0 || strcmp(ftext, "-_-NOFILE-_-") == 0) {fclose(html);return memError();}

            if (strstr(ftext, fcredits))
            {
                for (int i = strPos(ftext, fcredits); i < syze; i++) {ftext[i] = 0;}
                FILE *file = fopen(outfile, "w");
                if (file) {fputs(ftext, file);fclose(file);}
                else {return memError();}
            }
        }
        else {append = false;}
    }

        char mode[2];
        if (append) {sprintf(mode, "a");}
        else {sprintf(mode, "w");}

        FILE *html = fopen(outfile, mode);
        if (html)
        {
            // Start writing
            if (!append)
            {
                fputs("<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\t<title>", html);
                fputs(outfile, html);
                fputs("</title>\n\t<style>\n", html);
                fputs("\t\tbody {\n\t\t\tbackground-image: linear-gradient(to left, #80D0C7 0%, #add8e6 100%);\n\t\t}\n\n\t\t.solve {\n\t\t\tfont-weight: bold;\n\t\t\tborder: 3px solid red;\n\t\t}\n\n\t\th1 {\n\t\t\tfont-size: 40px;\n\t\t\tmargin-left: 18px;\n\t\t\tfont-family: \"Segoe UI\", Verdana, Helvetica, sans-serif;\n\t\t}\n\n\t\th2,h3,h4,h5,h6 {\n\t\t\tmargin-left: 18px;\n\t\t\tfont-family: Verdana, Helvetica, sans-serif;\n\t\t}\n\n\t\ttable {\n\t\t\tborder: 2px solid black;\n\t\t\tborder-collapse: collapse;\n\t\t\tmargin-left: 20px;\n\t\t}\n\n\t\ttd {\n\t\t\tborder: 2px solid black;\n\t\t\tpadding: 5px;\n\t\t\twidth: 20px;\n\t\t\theight: 20px;\n\t\t\ttext-align: center;\n\t\t\tfont-family: Helvetica, sans-serif;\n\t\t}\n", html);
                fputs("\t</style>\n</head>\n<body>\n", html);
            }

            // Write Command
            fputs("\t<h1>Command: ", html);
            for (int i = 0; i < 2; i++) {fputs(argv[i], html);fputc(' ', html);}
            for (int i = 0; i < tempf && i < 3; i++)
            {
                fputs(files[i], html);
                fputc(' ', html);
                if (i == 2) {fputs("...", html);}
            }
            for (int i = 0; i < temps && i < 3; i++)
            {
                fputs(words[i], html);
                fputc(' ', html);
                if (i == 2) {fputs("...", html);}
            }
            fputs("</h1>\n", html);

            // Write solution
            int foundWords = 0;

            // Loop
            for (int w = 0; w < temps; w++)
            {
                if (words[w] == NULL) {continue;}
                string word = words[w];
                int len = strlen(word);
                strlower(word);
                bool found = false;

                for (int i = 0; i < y; i++)
                {
                    for (int j = 0; j < x; j++)
                    {
                        if (p[j][i] != *word) {continue;}
                        else if (p[j][i] == 0) {return memError();}

                        // Check for each direction - x is j - y is i
                        // Create string for comparrison
                        char comp[len + 1];
                        comp[len] = 0;

                        // U
                        if (len <= i + 1)
                        {
                            for (int l = 0; l < len; l++)   //Updating string for comparison
                            {
                                comp[l] = tolower(p[j][i - l]);
                            }

                            if (strcasecmp(word, comp) == 0)
                            {
                                for (int l = 0; l < len; l++)
                                {
                                    p[j][i - l] = toupper(p[j][i - l]);
                                }
                                found = true;
                            }
                        }

                        // R
                        if (len + j <= x)
                        {
                            for (int l = 0; l < len; l++)   //Updating string for comparison
                            {
                                comp[l] = tolower(p[j + l][i]);
                            }

                            if (strcasecmp(word, comp) == 0)
                            {
                                for (int l = 0; l < len; l++)
                                {
                                    p[j + l][i] = toupper(p[j + l][i]);
                                }
                                found = true;
                            }
                        }

                        // D
                        if (len <= y - i)
                        {
                            for (int l = 0; l < len; l++)   //Updating string for comparison
                            {
                                comp[l] = tolower(p[j][i + l]);
                            }

                            if (strcasecmp(word, comp) == 0)
                            {
                                for (int l = 0; l < len; l++)
                                {
                                    p[j][i + l] = toupper(p[j][i + l]);
                                }
                                found = true;
                            }
                        }

                        // L
                        if (len <= j + 1)
                        {
                            for (int l = 0; l < len; l++)   //Updating string for comparison
                            {
                                comp[l] = tolower(p[j - l][i]);
                            }

                            if (strcasecmp(word, comp) == 0)
                            {
                                for (int l = 0; l < len; l++)
                                {
                                    p[j - l][i] = toupper(p[j - l][i]);
                                }
                                found = true;
                            }
                        }

                        // UR
                        if (len <= i + 1 && len <= y - j)
                        {
                            for (int l = 0; l < len; l++)   //Updating string for comparison
                            {
                                comp[l] = tolower(p[j + l][i - l]);
                            }

                            if (strcasecmp(word, comp) == 0)
                            {
                                for (int l = 0; l < len; l++)
                                {
                                    p[j + l][i - l] = toupper(p[j + l][i - l]);
                                }
                                found = true;
                            }
                        }

                        // UL
                        if (len <= i + 1 && len <= j + 1)
                        {
                            for (int l = 0; l < len; l++)   //Updating string for comparison
                            {
                                comp[l] = tolower(p[j - l][i - l]);
                            }

                            if (strcasecmp(word, comp) == 0)
                            {
                                for (int l = 0; l < len; l++)
                                {
                                    p[j - l][i - l] = toupper(p[j - l][i - l]);
                                }
                                found = true;
                            }
                        }

                        // DR
                        if (len <= x - i && len <= y - j)
                        {
                            for (int l = 0; l < len; l++)   //Updating string for comparison
                            {
                                comp[l] = tolower(p[j + l][i + l]);
                            }

                            if (strcasecmp(word, comp) == 0)
                            {
                                for (int l = 0; l < len; l++)
                                {
                                    p[j + l][i + l] = toupper(p[j + l][i + l]);
                                }
                                found = true;
                            }
                        }

                        // DL
                        if (len <= x - i && len <= j + 1)
                        {
                            for (int l = 0; l < len; l++)   //Updating string for comparison
                            {
                                comp[l] = tolower(p[j - l][i + l]);
                            }

                            if (strcasecmp(word, comp) == 0)
                            {
                                for (int l = 0; l < len; l++)
                                {
                                    p[j - l][i + l] = toupper(p[j - l][i + l]);
                                }
                                found = true;
                            }
                        }
                    }
                }

                if (found)
                {
                    fputs("\t<h2>Word \"", html);
                    fputs(word, html);
                    fputs("\" Found</h2>\n", html);

                    fputs("\t<table>\n", html);
                    for (int i = 0; i < y; i++)
                    {
                        fputs("<tr>", html);
                        for (int j = 0; j < x; j++)
                        {
                            if (isupper(p[j][i]))
                            {
                                fputs("<td class=\"solve\">", html);
                                fputc(p[j][i], html);
                                p[j][i] = tolower(p[j][i]);
                            }
                            else
                            {
                                fputs("<td>", html);
                                fputc(toupper(p[j][i]), html);
                            }
                            fputs("</td>", html);
                        }
                        fputs("</tr>\n", html);
                    }
                    fputs("\t</table><br><br>\n", html);

                    foundWords++;
                }
                else if (!ignore)
                {
                    fputs("\t<h2>Word \"", html);
                    fputs(word, html);
                    fputs("\" Not Found</h2><br>\n", html);
                }
            }

            printf("\t\tWords Found: %i/%i\n", foundWords, temps);

            fputs("\t<h3><i>", html);
            fputs("Words Found: ", html);
            if (foundWords > 0)
            {
                char a[foundWords];
                tostring(a, foundWords);
                fputs(a, html);
            }
            else {fputc('0', html);}
            fputc('/', html);
            char b[temps];
            tostring(b, temps);
            fputs(b, html);
            fputs("</i></h3>\n", html);
            fputs(fcredits, html);
            fputs("\n</body>\n</html>", html);
            fclose(html);
        }
        else {return memError();}

    // Close
    colorSet("c");
    printf("%s", credits);
    colorSet("reset");
    return 0;
}


// Functions



int memError()
{
    string credits = "\tResults Generated By Saabir's Word Searcher\n";
    colorSet("rb");
    printf("\t\t---MEMORY ERROR---\n\n");
    colorSet("c");
    printf("%s", credits);
    colorSet("reset");
    return -1;
}

int strPos(char str1[], char str2[])
{
    int l, i, j;

    //finding length of second string
    for (l = 0; str2[l] != '\0'; l++);

    for (i = 0, j = 0; str1[i] != '\0' && str2[j] != '\0'; i++)
    {
        if (str1[i] == str2[j])
        {
            j++;
        }
        else
        {
            j = 0;
        }
    }

    if (j == l)
    {
        return i - j;
    }
    return -1;
}

int findDM(char dm, string fname)
{
    FILE *test = fopen(fname, "r");
    if (test == NULL)
    {
        return -1;
    }
    bool valid = false;
    char t = ' ';
    while ((t = fgetc(test)) != EOF)
    {
        if (isalpha(t) && valid == false)
        {
            valid = true;
        }
    }
    fclose(test);
    if (!valid)
    {
        return 0;
    }

    FILE *file = fopen(fname, "r");
    // Error check
    if (file == NULL)
    {
        return -1;
    }
    int z = 0;
    char c = ' ';

    if (tolower(dm) == 'x')
    {
        // Find x
        z--;
        while ((c = fgetc(file)) != (char) 10)
        {
            if (isalpha(c))
            {
                z++;
            }
        }
    }
    else if (tolower(dm) == 'y')
    {
        // Find y
        while ((c = fgetc(file)) != EOF)
        {
            if ((short) c == 10)
            {
                z++;
            }
        }
    }
    else
    {
        return 0;
    }

    // Close
    fclose(file);
    return z + 1;
}

int strFindWords(string s)
{
    if (s == NULL)
    {
        return -1;
    }
    int len = strlen(s), size = 0;
    bool found = false;
    for (int i = 0; i < len; i++)
    {
        if (!isspace(s[i]) && !(s[i] == 10))
        {
            if (!found)
            {
                found = true;
                size++;
            }
        }
        else
        {
            found = false;
        }
    }
    return size;
}

bool strIncludesChar(string s, char c)
{
    int len = strlen(s);
    for (int i = 0; i < len; i++)
    {
        if (s[i] == c)
        {
            return true;
        }
    }
    return false;
}

bool strIsAlpha(string s)
{
    int len = strlen(s);
    for (int i = 0; i < len; i++)
    {
        if (!isalpha(s[i]))
        {
            return false;
        }
    }
    return true;
}

long findCharsf(string fname)
{
    FILE *file = fopen(fname, "r");
    if (file)
    {
        long rv = -1;
        char c = 0;
        do
        {
            rv++;
        }
        while ((c = fgetc(file) != EOF));
        fclose(file);
        return rv;
    }
    return -1;
}

long findCharf(string fname, char t)
{
    FILE *file = fopen(fname, "r");
    if (file == NULL)
    {
        return -1;
    }
    long chars = 0;
    char c;
    while ((c = fgetc(file)) != EOF)
    {
        if(c == t)
        {
            chars++;
        }
    }
    fclose(file);
    return chars;
}

void strExpf(string fname, char out[])
{
    string empty = "-_-FEMPTY-_-", error = "-_-MEMERROR-_-", nofile = "-_-NOFILE-_-";
    if(fname == NULL) {out = nofile;return;}

    long size = findCharsf(fname);

    switch (size)
    {
        case 0:
            out = empty;
            return;

        case -1:
            out = error;
            return;
    }

    FILE *file = fopen(fname, "r");
    if (file)
    {
        for (int i = 0; i < size; i++)
        {
            out[i] = fgetc(file);
        }
        out[size] = 0;
        fclose(file);
        return;
    }

    out = error;
    return;
}

bool gridf(string fname)
{
    FILE *file = fopen(fname, "r");
    int x = findDM('x', fname), y = findDM('y', fname);

    for (int i = 0; i < y; i++)
    {
        int len = 0;
        char c = ' ';
        while ((c = fgetc(file)) != EOF && c != (char) 10)
        {
            if (isalpha(c)) {len++;}
        }
        if (len != x)
        {
            fclose(file);
            return false;
        }
    }

    fclose(file);
    return true;
}

int findDigits(int number)
{
    int rv = 0;
    while(number / 10 > 1)
    {
        number /= 10;
        rv++;
    }
    return rv;
}

void tostring(char str[], int num)
{
    int i, rem, len = 0, n;

    n = num;
    while (n != 0)
    {
        len++;
        n /= 10;
    }
    for (i = 0; i < len; i++)
    {
        rem = num % 10;
        num = num / 10;
        str[len - (i + 1)] = rem + '0';
    }
    str[len] = '\0';
}

void strlower(string s)
{
    if (s)
    {
        int len = strlen(s);
        for (int i = 0; i < len; i++) {s[i] = tolower(s[i]);}
    }
}

void strupper(string s)
{
    if (s)
    {
        int len = strlen(s);
        for (int i = 0; i < len; i++) {s[i] = toupper(s[i]);}
    }
}